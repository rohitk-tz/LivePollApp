// Prisma Schema for Live Event Polling Application
// PostgreSQL 16 with ACID transactions

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Session Entity - Root aggregate for polling sessions
model Session {
  id          String       @id @default(uuid()) @db.Uuid
  presenterId String       @db.VarChar(255)
  title       String?      @db.VarChar(500)
  accessCode  String       @unique @db.VarChar(20)
  state       SessionState @default(Preparing)
  createdAt   DateTime     @default(now())
  startedAt   DateTime?
  pausedAt    DateTime?
  endedAt     DateTime?
  updatedAt   DateTime     @updatedAt

  // Relationships
  polls        Poll[]
  participants Participant[]
  events       EventLog[]

  @@index([presenterId])
  @@index([accessCode])
  @@map("sessions")
}

enum SessionState {
  Preparing
  Active
  Paused
  Ended
}

// Poll Entity - Question with multiple-choice options
model Poll {
  id          String    @id @default(uuid()) @db.Uuid
  sessionId   String    @db.Uuid
  question    String    @db.Text
  options     Json // JSONB: [{id, text, order}]
  state       PollState @default(Draft)
  createdAt   DateTime  @default(now())
  activatedAt DateTime?
  closedAt    DateTime?
  order       Int       @default(0)

  // Relationships
  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  votes   Vote[]

  @@index([sessionId])
  // Partial unique index for single active poll per session (handled in migration)
  @@map("polls")
}

enum PollState {
  Draft
  Active
  Closed
}

// Vote Entity - Participant response to poll option
model Vote {
  id              String           @id @default(uuid()) @db.Uuid
  pollId          String           @db.Uuid
  participantId   String           @db.Uuid
  optionId        String           @db.VarChar(255)
  state           VoteState        @default(Pending)
  submittedAt     DateTime         @default(now())
  validatedAt     DateTime?
  rejectionReason RejectionReason?

  // Relationships
  poll        Poll        @relation(fields: [pollId], references: [id], onDelete: Cascade)
  participant Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)

  @@index([pollId])
  @@index([participantId])
  // Unique constraint: one vote per participant per poll (handled in migration)
  @@map("votes")
}

enum VoteState {
  Pending
  Accepted
  Rejected
}

enum RejectionReason {
  DUPLICATE_VOTE
  POLL_CLOSED
  INVALID_OPTION
  SESSION_INACTIVE
}

// Participant Entity - Session attendee identity
model Participant {
  id              String           @id @default(uuid()) @db.Uuid
  sessionId       String           @db.Uuid
  anonymousId     String           @db.VarChar(100)
  state           ParticipantState @default(Joining)
  joinedAt        DateTime         @default(now())
  lastConnectedAt DateTime?
  disconnectedAt  DateTime?
  leftAt          DateTime?

  // Relationships
  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  votes   Vote[]

  @@unique([sessionId, anonymousId])
  @@index([sessionId])
  @@map("participants")
}

enum ParticipantState {
  Joining
  Connected
  Disconnected
  Left
}

// EventLog Entity - Audit trail and event replay buffer
model EventLog {
  id         BigInt     @id @default(autoincrement())
  sessionId  String     @db.Uuid
  eventType  String     @db.VarChar(100)
  entityType EntityType
  entityId   String     @db.Uuid
  payload    Json // JSONB: event-specific data
  timestamp  DateTime   @default(now())
  actorId    String?    @db.VarChar(255)

  // Relationships
  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId, timestamp])
  @@index([entityId])
  @@map("event_log")
}

enum EntityType {
  Session
  Poll
  Vote
  Participant
}
