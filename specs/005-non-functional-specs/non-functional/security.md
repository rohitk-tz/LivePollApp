# Security Requirements

**Created**: January 3, 2026  
**Status**: Draft  
**Feature**: 005-non-functional-specs

## Purpose

This specification defines security requirements for the Live Event Polling Application based on the "untrusted clients" trust model from the constitution. Requirements focus on protecting system integrity, preventing abuse, and maintaining participant privacy without exposing implementation details.

**References**:
- [Constitution](../../.specify/memory/constitution.md) - Trust Model, Privacy Philosophy
- [REST API Contracts](../../004-api-contracts/api/rest.md)
- [Real-Time Event Contracts](../../004-api-contracts/api/realtime.md)

---

## Security Principles

1. **Untrusted Clients**: All client input treated as potentially malicious
2. **Server-Side Validation**: Never trust client-side validation alone
3. **Least Privilege**: Actors receive minimum permissions required for their role
4. **Defense in Depth**: Multiple security layers (validation, rate limiting, authorization)
5. **Privacy by Default**: Anonymous participation, no personal data required
6. **Secure by Default**: Production deployments must use secure protocols

---

## Authentication and Authorization

### Access Control Model

**Roles**:
- **Presenter**: Creator and owner of session, full control over lifecycle
- **Participant**: Anonymous attendee who can join session and vote
- **Display**: Passive observer with no command authority

**Authorization Matrix**:

| Operation | Presenter | Participant | Display |
|-----------|-----------|-------------|---------|
| CreateSession | ✅ Yes | ❌ No | ❌ No |
| StartSession | ✅ Owner only | ❌ No | ❌ No |
| PauseSession | ✅ Owner only | ❌ No | ❌ No |
| ResumeSession | ✅ Owner only | ❌ No | ❌ No |
| EndSession | ✅ Owner only | ❌ No | ❌ No |
| CreatePoll | ✅ Owner only | ❌ No | ❌ No |
| UpdatePollDraft | ✅ Owner only | ❌ No | ❌ No |
| ActivatePoll | ✅ Owner only | ❌ No | ❌ No |
| ClosePoll | ✅ Owner only | ❌ No | ❌ No |
| JoinSession | ❌ N/A | ✅ Yes (with code) | ❌ N/A |
| SubmitVote | ❌ N/A | ✅ Yes (if joined) | ❌ No |
| View session | ✅ Yes | ✅ Yes | ✅ Yes |
| View active poll | ✅ Yes | ✅ Yes | ✅ Yes |
| View results | ✅ Yes | ✅ Yes | ✅ Yes |

---

### Session Access Control

**Requirement**: Session access codes prevent unauthorized session joins

**Access Code Properties**:
- **Length**: 6 characters (digits or alphanumeric)
- **Uniqueness**: Each session has unique code
- **Scope**: Code grants access to session only (not presenter privileges)
- **Lifetime**: Code valid from session creation until session ends
- **Visibility**: Only presenter and participants see code (not in public APIs)

**Validation**:
```
POST /sessions/{id}/join
{
  "accessCode": "ABC123"
}

→ 200 OK if code matches
→ 403 INVALID_ACCESS_CODE if code wrong
```

**Brute Force Protection**: Rate limit join attempts to 10/minute per IP

**Code Entropy**: 6 alphanumeric = 36^6 = 2.2 billion combinations (sufficient for short-lived codes)

---

### Presenter Authority Validation

**Requirement**: Only session owner can issue session/poll lifecycle commands

**Validation Mechanism** (implementation-agnostic):
1. Presenter creates session, receives presenter token/credential
2. Subsequent commands include presenter credential in request
3. System validates credential matches session owner
4. If mismatch, return 403 UNAUTHORIZED

**Example**:
```
POST /sessions/{id}/start
Authorization: Bearer <presenter-token>

→ 200 OK if token matches session owner
→ 403 UNAUTHORIZED if token wrong or missing
```

**Token Lifetime**: Valid for session duration + 24 hours (for post-event access to results)

---

### Participant Identity Management

**Requirement**: Participants anonymous but identifiable for duplicate vote detection

**Participant ID Properties**:
- Generated by system on JoinSession
- Unique per participant per session
- Anonymous (no personal data linked)
- Scoped to session (cannot use across sessions)

**Vote Linking**: System links votes to participant ID to enforce one-vote-per-poll rule

**Privacy Guarantee**: Participant IDs NEVER exposed in public events (VoteAccepted events show vote count updates, not participant IDs)

---

## Input Validation and Sanitization

### Request Payload Validation

**Requirement**: All REST requests validated against strict schemas

**Validation Rules**:
1. **Type Checking**: String, number, boolean, array types enforced
2. **Required Fields**: Missing required fields → 422 error
3. **Field Lengths**: Enforce maximum lengths (prevent buffer overflows, DoS)
4. **Allowed Characters**: Reject invalid characters in text fields
5. **Range Validation**: Numbers within expected ranges

**Example Validation**:
```json
{
  "question": "string (required, 1-500 chars, UTF-8)",
  "options": "array (required, 2-10 items)",
  "options[].text": "string (required, 1-200 chars, UTF-8)"
}
```

**Failure Response**:
```json
{
  "error": {
    "code": "INVALID_PAYLOAD",
    "message": "Validation failed",
    "details": [
      "question: must be between 1 and 500 characters",
      "options: must contain 2-10 items"
    ]
  }
}
```

---

### Text Input Sanitization

**Requirement**: Prevent injection attacks via user-provided text

**Sanitization Rules**:
1. **HTML Encoding**: Encode `<`, `>`, `&`, `"`, `'` characters
2. **Script Tags**: Strip or encode `<script>` tags
3. **SQL Injection**: Use parameterized queries (implementation detail, but required outcome)
4. **Command Injection**: No shell command execution from user input

**Fields Requiring Sanitization**:
- Session title, description
- Poll question text
- Poll option text

**Example**:
```
Input:  "Vote for <script>alert('XSS')</script> option"
Output: "Vote for &lt;script&gt;alert('XSS')&lt;/script&gt; option"
```

**Validation**: Penetration testing with XSS, SQL injection payloads, verify all sanitized

---

### URL Parameter Validation

**Requirement**: Validate all URL parameters (session IDs, poll IDs, etc.)

**Validation**:
- **UUID Format**: IDs must match UUID pattern (`[a-f0-9-]{36}`)
- **Existence**: ID must reference existing entity
- **Authorization**: Requester authorized to access entity

**Example**:
```
GET /sessions/abc-123/polls

→ 400 BAD_REQUEST if "abc-123" not valid UUID
→ 404 NOT_FOUND if session doesn't exist
→ 200 OK with data if valid and authorized
```

---

## Rate Limiting and Abuse Prevention

### REST API Rate Limits

**Requirement**: Prevent abuse via excessive API calls

**Rate Limits**:

| Endpoint Pattern | Limit | Window | Scope |
|-----------------|-------|--------|-------|
| POST /sessions | 10 requests | 1 hour | Per IP |
| POST /sessions/{id}/join | 10 requests | 1 minute | Per IP |
| POST /polls/{id}/votes | 1 request | 5 seconds | Per participant |
| All other POST | 100 requests | 1 minute | Per IP |
| All GET | 200 requests | 1 minute | Per IP |

**Rationale**:
- Session creation: Limit spam sessions
- Session join: Prevent brute force access code guessing
- Vote submission: One vote per poll enforced, rate limit prevents retry flooding
- General commands: Prevent DoS

**Exceeded Response**:
```
429 Too Many Requests
Retry-After: 45
{
  "error": {
    "code": "RATE_LIMIT_EXCEEDED",
    "message": "Too many requests, retry after 45 seconds"
  }
}
```

---

### Event Stream Connection Limits

**Requirement**: Prevent connection exhaustion attacks

**Connection Limits**:
- **Per IP**: 10 connections per minute
- **Per Session**: 1000 connections maximum (prevents one session monopolizing resources)
- **Global**: 5000 total connections (system capacity)

**Exceeded Behavior**:
- Per-IP limit: Reject new connections with 429 error
- Per-session limit: Oldest idle connection closed, new connection accepted
- Global limit: Reject new connections with 503 error

---

### Duplicate Vote Prevention

**Requirement**: Enforce one-vote-per-participant-per-poll rule

**Detection Mechanism**:
1. Participant submits vote on poll X
2. System checks if participant already voted on poll X
3. If yes, return 409 DUPLICATE_VOTE immediately (no database write)
4. If no, persist vote and return 202 ACCEPTED

**Race Condition Handling**: Use database unique constraint (participant_id, poll_id) to prevent concurrent duplicate votes

**Example**:
```
POST /polls/poll-1/votes
{ "participantId": "p-123", "selectedOptionId": "opt-1" }
→ 202 ACCEPTED

POST /polls/poll-1/votes (retry)
{ "participantId": "p-123", "selectedOptionId": "opt-2" }
→ 409 DUPLICATE_VOTE (even different option)
```

---

## Data Privacy and Protection

### Anonymous Participation

**Requirement**: No personal data required to vote per constitution

**Prohibited Data Collection**:
- ❌ Names
- ❌ Email addresses
- ❌ Phone numbers
- ❌ IP addresses (logged for rate limiting only, not linked to votes)
- ❌ Device identifiers

**Allowed Data Collection**:
- ✅ Session access codes (generated by system)
- ✅ Participant IDs (anonymous identifiers)
- ✅ Vote selections (linked to anonymous participant IDs)
- ✅ Timestamps (for ordering and analytics)

---

### Vote Anonymity

**Requirement**: Vote results show aggregate counts, never individual voter identities

**Public Events** (VoteAccepted):
```json
{
  "eventType": "VoteAccepted",
  "payload": {
    "pollId": "poll-1",
    "selectedOptionId": "opt-1",
    "updatedVoteCounts": [
      { "optionId": "opt-1", "voteCount": 42 }
    ],
    "totalVotes": 100
  }
}
```

**NOTE**: Participant ID NOT included in public event

**Private Logs** (internal only):
```
INFO: Vote accepted - poll=poll-1, participant=p-123, option=opt-1
```

**Logging Restriction**: Logs containing participant IDs never exposed via APIs or user-facing interfaces

---

### Data Retention and Deletion

**Requirement**: Short-lived data per constitution, deletion supported

**Retention Policy**:
- **Active Sessions**: Data retained while session active
- **Ended Sessions**: Data retained for 30 days (configurable)
- **Event Buffer**: 24 hours for replay
- **Logs**: 90 days for troubleshooting and compliance

**Deletion**:
- Automatic deletion after retention period
- Manual deletion on request (e.g., GDPR compliance)
- Deletion scope: Session, polls, votes, participants, events

**Deleted Data**:
- Not recoverable
- Queries return 404 NOT_FOUND

---

## Communication Security

### Transport Encryption

**Requirement**: Secure communication channels in production

**Protocols**:
- **REST API**: HTTPS (TLS 1.2 or higher)
- **Event Stream**: WSS (WebSocket Secure) or HTTPS for SSE

**Certificate Validation**: Clients must validate server certificates (prevent man-in-the-middle)

**[NEEDS CLARIFICATION]**: Should TLS be enforced in all environments or only production?

**Options**:

| Option | Answer | Implications |
|--------|--------|--------------|
| A | Enforce TLS in production only | Simpler local development, requires environment detection |
| B | Enforce TLS everywhere | Maximum security, complicates local setup with self-signed certs |
| C | Make TLS configurable | Flexible, risk of accidental insecure production deployment |

**Recommendation**: Option A (TLS in production only) with clear deployment documentation

---

### CORS Configuration

**Requirement**: Control which origins can access REST API from browsers

**Configuration Options**:
1. **Allow all origins** (`Access-Control-Allow-Origin: *`): Simple, suitable for public polling
2. **Allow specific origins**: More restrictive, requires configuration
3. **Environment-based**: Development allows all, production restricted

**Security Trade-off**: Polling app is public-facing, restricting origins provides minimal security benefit (access codes already required)

**Recommendation**: Allow all origins with access code protection as primary security mechanism

---

## Audit and Logging

### Security Event Logging

**Requirement**: Log security-relevant events for audit and incident response

**Logged Events**:
- Authentication failures (invalid presenter tokens, wrong access codes)
- Authorization failures (participant attempting presenter commands)
- Rate limit violations (potential abuse)
- Duplicate vote attempts (potential fraud)
- Input validation failures (potential injection attacks)
- Unusual patterns (e.g., rapid connection cycling)

**Log Format**:
```json
{
  "timestamp": "2026-01-03T10:15:30Z",
  "level": "WARN",
  "event": "AUTHORIZATION_FAILURE",
  "details": {
    "endpoint": "POST /sessions/abc-123/start",
    "ip": "203.0.113.42",
    "reason": "Invalid presenter token"
  }
}
```

**Log Protection**: Logs stored securely, access restricted to authorized personnel

---

### Audit Trail for Session Lifecycle

**Requirement**: Track all session state changes for accountability

**Audit Log Contents**:
- Session created by presenter X at timestamp T
- Session started by presenter X at timestamp T
- Poll created by presenter X at timestamp T
- Poll activated by presenter X at timestamp T
- Session ended by presenter X at timestamp T

**Purpose**: Accountability, troubleshooting, compliance

**Retention**: Same as session data retention policy (30 days)

---

## Denial of Service (DoS) Protection

### Resource Exhaustion Protection

**Threats**:
1. **Connection Exhaustion**: Attacker opens 10,000 connections
2. **Memory Exhaustion**: Attacker creates 1000 sessions with 10,000 participants
3. **CPU Exhaustion**: Attacker sends 100,000 malformed requests requiring validation

**Protections**:
1. **Connection Limits**: Max 5000 total connections, reject new at limit
2. **Session Limits**: Max 100 sessions per IP per hour
3. **Request Timeouts**: Reject requests taking > 5 seconds
4. **Payload Limits**: Max 1MB request body size
5. **Rate Limiting**: Throttle excessive request rates

---

### Distributed Denial of Service (DDoS) Protection

**Scope**: Large-scale attack from many IPs

**Protections** (implementation-agnostic):
1. **Network-Level Filtering**: Block traffic from known malicious IPs/ASNs
2. **Application-Level Rate Limiting**: Aggregate rate limits across all IPs
3. **Circuit Breaker**: Activate "siege mode" rejecting most new requests
4. **Content Delivery Network (CDN)**: Absorb traffic spikes

**Degradation Strategy**: Prioritize existing sessions over new session creation during attack

---

## Vulnerability Management

### Security Scanning

**Requirement**: Regular scanning for vulnerabilities

**Scanning Types**:
- **Static Analysis**: Code scanning for known vulnerability patterns
- **Dependency Scanning**: Check for vulnerable libraries/frameworks
- **Penetration Testing**: Ethical hacking to find exploits

**Frequency**:
- Static analysis: Every commit (CI/CD integration)
- Dependency scanning: Weekly
- Penetration testing: Quarterly

**Remediation**:
- Critical vulnerabilities: Fix within 7 days
- High vulnerabilities: Fix within 30 days
- Medium vulnerabilities: Fix within 90 days

---

### Security Patching

**Requirement**: Apply security patches promptly

**Process**:
1. Monitor security advisories for dependencies
2. Evaluate severity and applicability
3. Test patches in staging environment
4. Deploy to production during maintenance window
5. Verify patch effectiveness

**Emergency Patching**: Critical vulnerabilities deployed within 24 hours (may require downtime)

---

## Security Testing Strategy

### Penetration Testing Scenarios

**Scenario 1: SQL Injection**
- **Attack**: Submit poll question with SQL injection payload
- **Expected**: Payload sanitized, no database query execution

**Scenario 2: XSS Attack**
- **Attack**: Submit poll option with `<script>` tag
- **Expected**: Script tag encoded, not executed in clients

**Scenario 3: Access Code Brute Force**
- **Attack**: Try 100 different access codes for session join
- **Expected**: Rate limit after 10 attempts, account locked

**Scenario 4: Unauthorized Command**
- **Attack**: Participant tries to POST /sessions/{id}/start
- **Expected**: 403 UNAUTHORIZED, command rejected

**Scenario 5: Duplicate Vote Flooding**
- **Attack**: Submit same vote 1000 times rapidly
- **Expected**: First accepted, rest rejected with 409, no performance impact

**Scenario 6: Connection Exhaustion**
- **Attack**: Open 10,000 event stream connections
- **Expected**: Rate limit after 10/minute, others rejected

**Validation**: All attacks mitigated per specification, zero successful exploits

---

### Secure Development Practices

**Requirements** (process, not system):
1. Code reviews for all changes (catch security issues early)
2. Principle of least privilege in code (minimize blast radius)
3. Input validation at every boundary (never trust external input)
4. Secure defaults in configuration (e.g., TLS enabled by default in production)
5. Security training for developers (awareness of common vulnerabilities)

---

## Constitution Alignment

### Untrusted Clients Trust Model

**Requirement**: "Attendees are considered untrusted clients"

**Security Alignment**:
- ✅ Server-side validation for all votes
- ✅ Rate limiting prevents abuse
- ✅ Duplicate vote detection
- ✅ Input sanitization prevents injection
- ✅ Authorization prevents privilege escalation

---

### Presenter Authority Principle

**Requirement**: "Presenter exclusively controls poll lifecycle and session state"

**Security Alignment**:
- ✅ Presenter token validation
- ✅ Authorization matrix enforces role separation
- ✅ Participants cannot issue presenter commands
- ✅ Display has zero command authority

---

### Privacy by Default

**Requirement**: "Anonymous participation is the default, no personal data required"

**Security Alignment**:
- ✅ No personal data collected
- ✅ Participant IDs anonymous
- ✅ Votes not linked to individuals in public events
- ✅ Data retention policies support deletion

---

## Security Acceptance Criteria

System meets security requirements when:

1. ✅ All REST endpoints validate payloads, reject malformed requests with 422
2. ✅ Rate limiting blocks excessive requests (>100/min), returns 429
3. ✅ Penetration testing finds zero critical vulnerabilities
4. ✅ XSS and SQL injection tests show all inputs sanitized
5. ✅ Unauthorized commands rejected with 403 (participant attempting presenter operations)
6. ✅ Duplicate votes rejected immediately with 409
7. ✅ Access code brute force blocked after 10 attempts
8. ✅ Connection exhaustion attack limited to 5000 connections
9. ✅ TLS enforced in production environments (HTTPS/WSS)
10. ✅ No personal data collected, audit confirms privacy compliance

**Sign-off**: Security validated via penetration testing before production deployment
